module TypeDescriptorGrammar;

Identifier      : { 'a'-'z' | 'A'-'Z' | '0'-'9' } ;
Type            : Primitive | Wrapper | Function | Generic ;
Primitive       : "Never" | "Unit" | "Int" | "Float" | "Boolean" | "String" ;
Wrapper         : [ { ArraySpec | NullabilitySpec | MutabilitySpec } ":" ] Type ;
ArraySpec       : "a" ;
MutabilitySpec  : "m" ;
NullabilitySpec : "n" ;
Function        : "$"  Arity ArgumentList ReturnType Identifier ;
Lambda          : "\\" Arity ArgumentList ReturnType ;
Arity           : Integer ;
ArgumentList    : { Type } ; # (*  * is Arity  *)
ReturnType      : Type ;
Generic         : "@" Arity Type ArgumentList ;
TypeParamSpec   : "#" ;
TypeParam       : TypeParamSpec Identifier ;

# Int                              ::= :Int
# String?                          ::= n:String
# &Person?                         ::= nm:Person
# &List<Person?>                   ::= @ 1 m:List n:Person
# <T> List<T>                      ::= @ 1 :List #:T
# Person?[]?[]?                    ::= nanan:Person ????? <- does this even make sense wtf
#                                                            do i just make arrays generic
# () -> () -> Unit                 ::= \ 0 $ 0 Unit
# (() -> Unit) -> Unit             ::= \ 1 $ 0 Unit Unit
# (() -> Unit) -> () -> Unit       ::= \ 1 $ 0 Unit $ 0 Unit
# (Int, (Int?) -> Bool) -> String? ::= \ 2 Int $ 1 n:Int Bool n:String
#
# map<T, R>(list: List<T>, transform: (T) -> R): List<R>
#                                  ::= $ 2 @ 1 List #T $ 1 #T #R @ 1 List #R map

# INFERENCE
# let l = () -> 5                  ::= () -> Int
# let x =  (a, b) -> a + b         ::= (#A, #B) -> <infer>
#
# x(1, 2)                          ::= resolve call x with Int Int
#                                  ::= lookup       x ::= (#A, #B) -> <infer>
#                                  ::= instantiate  x ::= (Int, Int) -> <infer>
#                                  ::= resolve      a: Int + b: Int
#                                            |         Int + Int
#                                            |         Int
#                                  ::= resolved     x(Int, Int) -> Int succesfully,
#                                  ::= call to x with Int Int is valid
#
# x("hello", 2)                    ::= resolve call x with String Int
#                                  ::= lookup       x ::= (#A, #B) -> <infer>
#                                  ::= instantiate  x ::= (String, Int) -> <infer>
#                                  ::= resolve      a: String + b: Int
#                                            |         String + Int
#                                            |         RESOLUTION ERROR
#                                  ::= resolution failed, reason:
#                                  ::= String + Int is not a valid binary operation
#                                  ::= call to x with String Int is invalid
#
# let add5 = a -> l() + a          ::= (#A) -> <infer>
#                                  ::= attempt to resolve lambda body l() + a
#                                  ::= lookup       l ::= () -> Int
#                                  ::= resolve call l ::= Int
#                                  ::= resolve      Int + a: #A
#                                  ::=
